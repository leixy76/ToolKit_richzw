
- [RisingWave 流处理 Join](https://mp.weixin.qq.com/s/u_9Y_cuOiuRGT17XU_34zA)
  - Symmetric Hash Join
  - Interval Join
    - Interval Join允许两个事件在一定的时间间隔内连接，而不是在严格的窗口期间内
  - Temporal Join
    - 传统数据库中的Hash Join只需要选择一边建立Hash Table。为了提高性能，一个思考方向是打破对Join两边输入的对等关系
    - Risingwave提供Temporal Join，它可以将一边流Join一个Risingwave内部表或者物化视图，流的一边可以不再维护状态，当有数据过来时，可以直接查询另外一边的表，同时表则充当了Join状态本身
  - Join Ordering
    - 传统数据库中针对Join Ordering的优化文献浩如烟海，其中很重要的一个思想是利用CBO（Cost Based Optimizer）来枚举执行计划搜索空间， 利用表的统计信息，估算每个算子的需要处理的数据量，计算出执行计划的代价，最后采用估算代价最低的执行计划。
    - Risingwave目前使用的Join Ordering算法是**尽量地将这棵树变成Bushy Tree并使得它的树高最低**
  - NestedLoop Join
  - Delta Join
  - 快慢流 / Multi-Way Joins
- 对象存储优化
  - 流式写入
    - 在 LSM compaction 或算子状态持久化期间，我们需要将已排序的键值对写入多个 SST 文件中。一种直接的方法是在内存中缓冲整个SST，并在其大小达到容量时启动后台任务进行上传。
    - 我们使用 Multipart上传来解决这个问题。它允许将单个对象上传为一组parts；每个 part 是待上传对象的一个连续部分
  - 流式读取
    - LSM compaction 期间，我们还需要读取和遍历 SST 文件
    - AWS SDK 提供了一个函数into_async_read 来把返回的 HTTP 流封装成一个 tokio::io::AsyncRead 对象。然后我们可以在这个对象上调用 read_exact ，以字节流的形式读取数据。
    - 我们在 SST 字节流上创建了一个 BlockStream 抽象。其可以根据 SST 元数据以块为粒度进行读取，并解析其中的键值对，做归并排序。
  - S3 存储桶支持多个前缀
    - 我们采用了一种简单的方法来设置集群的最大前缀数量，并基于其 ID 的哈希值将 SST 文件分配到不同的前缀中。例如，我们可以将最大前缀数配置为128，理论上可以支持每秒 3,500 * 128 的写入或 5,500 * 128 的读取请求。
- 利用随机化的 SQL 测试来帮助检测错误
  - SQLSmith 是一个用于自动生成和测试 SQL 查询的工具。它旨在通过生成随机的有效 SQL 查询并在目标数据库上执行这些查询来探索数据库系统的功能和限制。


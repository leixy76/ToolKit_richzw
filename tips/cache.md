
- [如何保证缓存和数据库的一致性](https://mp.weixin.qq.com/s?__biz=MzIyOTYxNDI5OA==&mid=2247487312&idx=1&sn=fa19566f5729d6598155b5c676eee62d&scene=21#wechat_redirect)
  - 缓存利用率和一致性问题
    - 先更新缓存，后更新数据库

      如果缓存更新成功了，但数据库更新失败，那么此时缓存中是最新值，但数据库中是「旧值」。

      虽然此时读请求可以命中缓存，拿到正确的值，但是，一旦缓存「失效」，就会从数据库中读取到「旧值」，重建缓存也是这个旧值
    - 先更新数据库，后更新缓存

      如果数据库更新成功了，但缓存更新失败，那么此时数据库中是最新值，缓存中是「旧值」。

      之后的读请求读到的都是旧数据，只有当缓存「失效」后，才能从数据库中得到正确的值。
  - 并发引发的一致性问题
    - 先更新数据库，再更新缓存

      有线程 A 和线程 B 两个线程，需要更新「同一条」数据，会发生这样的场景：
      - 线程 A 更新数据库（X = 1）
      - 线程 B 更新数据库（X = 2）
      - 线程 B 更新缓存（X = 2）
      - 线程 A 更新缓存（X = 1）
      
      最终 X 的值在缓存中是 1，在数据库中是 2，发生不一致
    - 先更新缓存，再更新数据库的方案，也会有类似问题

  - 删除缓存可以保证一致性吗？
    
    首先，经过前面的分析我们已经得知，以下两个方案但凡「第二步」操作失败，都会导致数据不一致。
    - 先删除缓存，后更新数据库

      如果有 2 个线程要并发「读写」数据，可能会发生以下场景：

      - 线程 A 要更新 X = 2（原值 X = 1）
      - 线程 A 先删除缓存
      - 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
      - 线程 A 将新值写入数据库（X = 2）
      - 线程 B 将旧值写入缓存（X = 1）
      
      最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。
    - 先更新数据库，后删除缓存

      依旧是 2 个线程并发「读写」数据：

      - 缓存中 X 不存在（数据库 X = 1）
      - 线程 A 读取数据库，得到旧值（X = 1）
      - 线程 B 更新数据库（X = 2)
      - 线程 B 删除缓存
      - 线程 A 将旧值写入缓存（X = 1）
      
      最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），也发生不一致。 这种情况「理论」来说是可能发生的，但实际真的有可能发生吗？
      其实概率「很低」，这是因为它必须满足 3 个条件：
      - 缓存刚好已失效
      - 读请求 + 写请求并发
      - 更新数据库 + 删除缓存的时间（步骤 3-4），要比读数据库 + 写缓存时间短（步骤 2 和 5）
      
      仔细想一下，条件 3 发生的概率其实是非常低的。 因为写数据库一般会先「加锁」，所以写数据库，通常是要比读数据库的时间更长的。

      这么来看，「先更新数据库 + 再删除缓存」的方案，是可以保证数据一致性的。

  - 如何保证两步都执行成功？

    - 无论是更新缓存还是删除缓存，只要第二步发生失败，那么就会导致数据库和缓存不一致。
    最简单的解决办法是什么？ 答案是：重试。

      现实情况往往没有想的这么简单，失败后立即重试的问题在于：

      - 立即重试很大概率「还会失败」
      - 「重试次数」设置多少才合理？
      - 重试会一直「占用」这个线程资源，无法服务其它客户端请求

    - 更好的方案应该怎么做？ 答案是：**异步重试**

      其实就是把重试请求写到「消息队列」中，然后由专门的消费者来重试，直到成功

    - 是否有更简单的方案，同时又可以保证一致性呢？ 订阅数据库变更日志，再操作缓存

  结论，想要保证数据库和缓存一致性，推荐采用「先更新数据库，再删除缓存」方案，并配合「消息队列」或「订阅变更日志」的方式来做。

- 主从库延迟和延迟双删问题
  - 第一个问题，还记得前面讲到的「先删除缓存，再更新数据库」方案，导致不一致的场景么？

    2 个线程要并发「读写」数据，可能会发生以下场景：
    - 线程 A 要更新 X = 2（原值 X = 1）
    - 线程 A 先删除缓存
    - 线程 B 读缓存，发现不存在，从数据库中读取到旧值（X = 1）
    - 线程 A 将新值写入数据库（X = 2）
    - 线程 B 将旧值写入缓存（X = 1）
    - 最终 X 的值在缓存中是 1（旧值），在数据库中是 2（新值），发生不一致。

  - 第二个问题：是关于「读写分离 + 主从复制延迟」情况下，缓存和数据库一致性的问题。

    在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」其实也会导致不一致：

    - 线程 A 更新主库 X = 2（原值 X = 1）
    - 线程 A 删除缓存
    - 线程 B 查询缓存，没有命中，查询「从库」得到旧值（从库 X = 1）
    - 从库「同步」完成（主从库 X = 2）
    - 线程 B 将「旧值」写入缓存（X = 1）
    - 最终 X 的值在缓存中是 1（旧值），在主从库中是 2（新值），也发生不一致。

    看到了么？这 2 个问题的核心在于：缓存都被回种了「旧值」。

    最有效的办法就是，把缓存删掉。这就是业界给出的方案：**缓存延迟双删策略**
    - 解决第一个问题：在线程 A 删除缓存、更新完数据库之后，先「休眠一会」，再「删除」一次缓存。
    - 解决第二个问题：线程 A 可以生成一条「延时消息」，写到消息队列中，消费者延时「删除」缓存。

    但问题来了，这个「延迟删除」缓存，延迟时间到底设置要多久呢？
      - 问题1：延迟时间要大于「主从复制」的延迟时间
      - 问题2：延迟时间要大于线程 B 读取数据库 + 写入缓存的时间
    
    但是，这个时间在分布式和高并发场景下，其实是很难评估的。 很多时候，我们都是凭借经验大致估算这个延迟时间，例如延迟 1-5s，只能尽可能地降低不一致的概率。

- ALL in all

  - 引入缓存后，需要考虑缓存和数据库一致性问题，可选的方案有：「更新数据库 + 更新缓存」、「更新数据库 + 删除缓存」
  - 更新数据库 + 更新缓存方案，在「并发」场景下无法保证缓存和数据一致性，且存在「缓存资源浪费」和「机器性能浪费」的情况发生
  - 在更新数据库 + 删除缓存的方案中，「先删除缓存，再更新数据库」在「并发」场景下依旧有数据不一致问题，解决方案是「延迟双删」，但这个延迟时间很难评估，所以推荐用「先更新数据库，再删除缓存」的方案
  - 在「先更新数据库，再删除缓存」方案下，为了保证两步都成功执行，需配合「消息队列」或「订阅变更日志」的方案来做，本质是通过「重试」的方式保证数据一致性
  - 在「先更新数据库，再删除缓存」方案下，「读写分离 + 主从库延迟」也会导致缓存和数据库不一致，缓解此问题的方案是「延迟双删」，凭借经验发送「延迟消息」到队列中，延迟删除缓存，同时也要控制主从库延迟，尽可能降低不一致发生的概率
  
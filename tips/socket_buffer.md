
一个socket ，会带有两个缓冲区，一个用于发送，一个用于接收
- 用户发送消息的时候写给 send buffer（发送缓冲区）
- 用户接收消息的时候写给 recv buffer（接收缓冲区）

查看 socket 缓冲区，可以在linux环境下执行 `netstat -nt` 命令
- Send-Q 是发送缓冲区
- Recv-Q 代表接收缓冲区

TCP
-------

- 执行 send 发送的字节，会立马发送吗

![img.png](socket_sent.png)

- 如果缓冲区满了会怎么办

![img_1.png](socket_recv.png)

- 如果socket缓冲区还有数据，执行close了，会怎么样
  - 如果接收缓冲区有数据时，执行close了，会怎么样
    - 如果接收缓冲区还有数据未读，会先把接收缓冲区的数据清空，然后给对端发一个RST。
    - 如果接收缓冲区是空的，那么就调用 tcp_send_fin() 开始进行四次挥手过程的第一次挥手
  - 如果发送缓冲区有数据时，执行close了，会怎么样
    - 内核会把发送缓冲区最后一个数据块拿出来。然后置为 FIN。
    - socket 缓冲区是个先进先出的队列，这种情况是指内核会等待TCP层安静把发送缓冲区数据都发完，最后再执行四次挥手的第一次挥手（FIN包）

UDP
-------

我们大部分情况下，都不会用  MSG_MORE，也就是来一个数据包就直接发一个数据包。从这个行为上来说，虽然UDP用上了发送缓冲区，但实际上并没有起到"缓冲"的作用

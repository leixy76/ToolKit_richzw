
- [gRPC flow control](https://www.youtube.com/watch?v=EEEGBwEA8yA)
  - TCP congestion control
    - Common Algorithm
      - Reno
      - BIC
      - CUBIC
    - General Strategy
      - Incr sending rate if ACK
      - Decr if ACK missed
  - TCP flow control
    - Stop reading kernel buffer
    - Receiver drop further packets
    - Receiver being protected
    - Trigger Impact
      - Reduce throughput
      - Degraded multiplexing
  - gRPC flow control
    - Algorithm similar to Token Bucket (WINDOW_UPDATE Frame)
    - Features
      - High performance
      - Fine grained throttling - Stream (RPC)/ Connection
      - Frame Priority
  - Window Size
    - Solution: BDP estimator - Bandwidth Delay Product: the amount of data that can be in transit in the network
    - Goal: intelligently avoid triggering flow control
    - Measure BDP through PING frame and PID controller
    - Set the _init window size_ to BDP
  - Challenge
    - Fairness between RPCs  - HTTP2 flow control supports multiplexing
    - Throttle based on performance - gRPC has BDP estimator
    - Flow control From End to End - gRPC has built-in Flow control

- [Best Practice](https://www.youtube.com/watch?v=Z_yD7YPL2oE)

  - API Design - Idempotency   
    - Request should include timestamp/guid to make idempotency
  - API Design - Performance
    - Request: can imply unbounded work -- set limits
    - Response: pagination
    - Avoid long-running operation  - 
  - API Design - Defaults
    - Unset enums default to zero value, perfer UNKNOWN/UNSECIFIED as the default
    - Backward compatibility
  - API Design - Errors
    - Do not include in response payload in most cases
    - Avoid batching multiple, independent operations
  - Error Handling - Don't Panic!
    - Do not blindly return errors from libs or ther services
  - Deadlines - Propagation
    - `Context.WithDeadline(.. Time percificed)` or `WithTimeout(…  -` 
  - Rate Limiting
    - Local rate limits
      - `Grpc.InTapHandler(rateLimiter`)`
      - `Golang.org/x/time/rate`    -- rate.NewLimiter(…)
  - Retries.
    - Officail grpc plan to do that
      - Configured via server config
      - Supports
        - Sequential retries with backoff
        - Concurrent hedged request
    - Until then: use a client wrapper or interceptor
      - Accept a content and use its deadline
  - Memory Management
    - Grpc does not limit goroutines
      - Option1: set listener limits and concurrent stream limits
        - `Listener = netutil.LimitListener(listener, connectionLimit)`
        - `Grpc.NewServer(grpc.MaxConcurrentSteams(streamsLimit))`
      - Option2: use TapHandler to error when too many rpcs are in flight
      - Option3: use health report and load balance to redirect traffic
    - Large request can OOM
      - Set a max request payload size
         `Grpc.NewServer(grpc.MaxRecvMsgSize(4096/*bytes*/))`


